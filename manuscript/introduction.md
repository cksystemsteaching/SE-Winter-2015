{mainmatter}

# 1. Introduction

{#introduction}

---

Disclaimer:

This is work in progress. Only two chapters are done with a third getting ready in Fall 2015. Others exist in draft form but will take more time to be done.

---

Computer science is a mystery to so many and yet more and more people use computers every day in one form or another. There are increasingly many people with all kinds of backgrounds other than computer science that even develop software, sometimes without even knowing it. At colleges and universities around the world there is hardly anyone left who is not confronted with the machine and its code. The way this often works is by searching for a solution of a given problem on the Internet and then adapt the solution to the actual application. All this is typically done with only a vague understanding of what the code actually means and how the machine performs when running it. The consequences of that are well-known and too numerous and boring to list here.

While a book about computer science for everyone may sound appealing it actually requires serious commitment to understand the material even though we tried very hard to simplify everything as much as possible. The reason is that computers and software are so expressive that it is unlikely that any other computational machine in the future will be more expressive. Anything that can be computed can be computed now, if you have enough time.

Selfie is an educational software system that has grown out of many years of teaching undergraduate and graduate classes in computer science. The key observation is that understanding the meaning of software and ultimately the behavior of a computer can only be achieved by understanding how software translates all the way down to the bits of the machine. Selfie shows how to do that. This may sound scary but can actually be done in a systematic fashion using only basic principles.

The first step is to accept the fact that software has no a-priori meaning whatsoever until that moment when it is actually executed by a machine. As is, it is just a sequence of characters encoded in bits whose meaning is, if at all, in the mind of the person looking at it. Whether that meaning matches the meaning assigned to it by the machine executing it is the question addressed here. So where does the meaning of software come from? Ultimately it is the physics of the machine executing it. Take another machine and you will get another meaning depending on how close you look even for the exact same software. We explore some of the basic principles behind this line of thought in the first chapter after the introduction.

The next logical step is to look at how a computer really works. In typical computer science curricula this is done as part of so-called architecture classes where architecture really means processor architecture. This may also sound scary but is in fact the easiest part of all. We went through quite a few iterations to identify a realistic machine model that represents an existing, widely used processor called MIPS but only features what is in principle necessary to get to the point. We call this subset MIPSter! Selfie implements a MIPSter emulator called mipster which is software that mimics the MIPSter portion of an actual MIPS processor. In other words, mipster can execute MIPSter code. This is a fun chapter that everyone can understand and which is next in line to be published.

After that we take a little break and reflect on the capabilities and limitations of such a machine. It turns out that all computers have the same computational power. They can all compute exactly the same stuff. They even do so at the same speed up to a constant factor, really. This means in particular that the speed at which a given piece of software can solve a problem does not fundamentally change by taking a faster machine unless it is a quantum computer. The only way out currently available is to improve the software and even then there are limits.

This topic is actually three topics: computability, algorithmic complexity, and computational complexity. The term computability suggests that there are also things that cannot be computed which is fascinating and important to know about. The difference between the other two topics is that algorithmic complexity focuses on the principled performance of an algorithm whereas computational complexity is about the principled difficulty of solving a problem (for which there may be many algorithms to solve it). Usually these topics are taught in multiple classes. Our goal is to do only the minimum necessary to get the relevant information across. Unfortunately, the chapter is unfinished and will take more time to get done. Fortunately, however, the following steps can be taken without it.

The next, in fact crucial step is to understand how software, which is mostly written in some high-level programming language, is actually translated to machine code such as MIPSter that can be executed by a real processor or an emulator like mipster. The reason why this step is crucial is because that translation, also called compilation, determines the meaning of software in terms of the meaning of the machine code to which it is compiled. Thus if we understand the machine and compilation we understand high-level programming. Now this may really sound scary and it actually is unless things are simplified and truly focused on basic principles.

Similar to the design of MIPSter we spent a lot of effort on identifying a  minimal subset of a real, widely used programming language that we call C Star (C\*) which is sufficient to cover all information relevant at this point. C\* is a tiny subset of the programming language C which is infamous for its complexity but widely used for many technical and historical reasons. In contrast, C\* is so simple that it can be learned fast, even by programming novices. The key operator is the star (\*) operator from C which takes a number and uses it to refer to an address of a memory cell. This enables us to read from and write to all of a machine's memory. Many other features of C are missing such as data structures, bitwise operators, and Boolean expressions.

C\* is, however, still sufficiently expressive to do something incredibly cool: we use C\* to define the meaning of C\*. This is done by implementing a so-called compiler in C\* that compiles any software written in C\* including itself to MIPSter which then becomes executable by mipster and thus a MIPS processor. That compiler, which we call cstarc, is thus *self-compiling* and like mipster part of selfie. However, not only cstarc is written in C\*, mipster is as well. This means that mipster compiled with cstarc can execute itself. It is what we call *self-executing*. By now the name selfie should be self-explanatory. If you are anyway lost by now there is hope. In our experience understanding that kind of *self-referentiality* takes time and serious commitment but once there is understanding many other important aspects of computer science fall into place.

The final step of this book for which there exists a draft chapter is to explain concurrency, that is, how a computer appears to be doing many things at the same time even though logically at its core it is a sequential machine that can only take one step at a time. For this purpose we enhance mipster such that it can emulate many copies of itself by executing one copy for a while and then switching to the next and so on. This is at the lowest level what an operating system does. Since mipster can execute itself we can then show how that switching logic and other operating systems functionality can be executed by mipster rather than by being part of mipster. By making that step explicit self-referentiality of operating system software is fully exposed and true understanding of the matter, which is traditionally very hard to obtain, becomes possible even for a larger audience.

There are also plans for other chapters on data structures, memory management, and how a computer handles input and output. These topics are important and will eventually be covered.

---

Acknowledgements:

The ideas presented here are the result of many years of teaching and working with students and colleagues around the world. I am grateful to my group of students and faculty in Salzburg who helped me over the years with refining and deepening my understanding of computer science. I am also particularly grateful to my colleague Professor Raja Sengupta at UC Berkeley who challenged me to the point that made me discover what has now become the Selfie Project. The design of the compiler is inspired by the Oberon compiler of Professor Niklaus Wirth from ETH Zurich.